# text/template 概览（译）

原文链接：<https://pkg.go.dev/text/template#pkg-overview>

template 包用于实现生成文本的输出了数据驱动模板。

要生成 html 输出，查阅 html/template 包，提供了和这个包相同的接口，不同的是会自动保护输出以防止某些攻击。

模板通过将数据结构应用给他们来执行。模板中的注解引用了数据结构中的元素（一般是结构体中的字段或者字典中的键）来控制执行和导出要展示的值。模板的执行会遍历这个结构并且设置一个游标，句号 `.` 也叫点，代表了执行过程中结构中当前未知的值。

模板输入的文本是任何格式的 utf-8 编码的文本。”动作“（Actions）--数据计算和结构控制--通过 `{{` 和 `}}` 分隔；所有的”动作“之外的文本会原样复制到输出。

一旦开始解析，一个模板会安全地并发执行，尽管并发执行共享了一个输出可能会导致错乱。

这里有一个小例子，输出 `17 items are made of wool`（17件羊毛制品）

```
type Inventory struct {
	Material string
	Count    uint
}
sweaters := Inventory{"wool", 17}
tmpl, err := template.New("test").Parse("{{.Count}} items are made of {{.Material}}")
if err != nil { panic(err) }
err = tmpl.Execute(os.Stdout, sweaters)
if err != nil { panic(err) }
```

下面有更多复杂的例子

## 文本和空白

默认情况下，所有动作之间文本在执行过程是逐字拷贝的。举例来说，上面示例中的字符串 `items are made of` 在程序运行的时候会出现在标准输出。

然而，为了帮助格式化源代码，如果一个动作的左分隔符（默认是 `{{`）后面立马跟一个减好和空白，所有尾随的空白会被之前的文本剪裁掉。类似的，如果一个右分隔符（默认是 `}}`）前面有空白和一个减号，接下来的文本中所有前置的空白会被剪裁掉。在这些剪裁标记中，必须有空白：`{{- 3}}` 和 `{{3}}` 类似，只是剪裁了前面的文本，但是 `{{-3}}` 会被解析成一个包含数字 `-3` 的动作。

举个例子，当执行模板的代码是

```
"{{23 -}} < {{- 45}}"
```

生成的输出是

```
"23<45"
```

在这个剪裁中，空白字符的定义和 go 的空白是一致的，包括空格，制表符，回车和换行。

## 动作

这是动作的列表。“参数”和“管道”都是数据的计算，后面的章节中有详细的定义。

```
{{/* 注释 */}}
{{- /* 带去掉前后空白的注释 */ -}}
    注释；丢弃的。可以包含换行符号。
    注释不能内嵌，必须在开始和结束符号（`{{}}`）中间，就像这里展示的那样。

{{pipeline}}
    管道值的默认文本表示（和 fmt.Print 打印一样）会被复制到输出中

{{if pipeline}} T1 {{end}}
    如果管道的值是空的，不会有输出生成；
    否则 T1 会被执行。这个空值包括 false，0，任何空指针或者 interface，以及任何长度为 0 的数组，切片，字典或者字符串。
    点号是不受影响的。

{{if pipeline}} T1 {{else}} T0 {{end}}
    如果管道中的值是空的，T0 会执行；
    否则 T1 会执行。点号是不受影响的。

{{range pipeline}} T1 {{end}}
    管道的值必须是一个数组，切片，字典，或者 channel。
    如果管道中的值的长度是 0，没有任何东西输出；
    否则，点号被设置成数组，切片，字典的连续元素，并且 t1 会执行。
    如果值是一个字典，并且键是有顺序的基本类型，这些元素可以按键的顺序访问。

{{break}}
    最里层的循环 `{{range pipelie}}` 提前结束，停止当前的迭代，并且跳过剩下的迭代

{{continue}}
    当前迭代的最里层循环 `{{range pipeline}}` 被终止，并且这个循环从下一次迭代开始。

{{template "name"}}
    特定名字的模板会使用空的数据执行。

{{template "name" pipeline}}
    特定名字的模板会执行，其中点号会被设置成管道的值

{{block "name" pipeline}} T1 {{end}}
    块是定义模板的缩写
        {{define "name"}} T1 {{end}}
    然后原地执行它
        {{template "name" pipeline}}
    典型用法是定一个一些基础模板的集合，然后通过在里面重新定义模板来进行定制。

{{with pipeline}} T1 {{end}}
    如果管道中的值是空的，不会生成输出；
    否则，点号会被设置成管道中的值，并且 T1 会执行

{{with pipeline}} T1 {{else}} T0 {{end}}
    如果管道中的值是空的，点号受影响，并且 T0 会执行；
    否则点号被设置成管道中的，并且 T1 会执行。
```

## 参数

参数是一个简单的值，用以下之一表示。

- go 语法中的布尔，字符串，字符，整型，浮点型，虚数或者复数常量。这些行为类似 Go 中没有类型的常量。注意，与 Go 中一样，整型常量赋值或者传递给一个函数的时候会不会溢出，取决于宿主机器的整型是 32 还是 64 位。
- 关键字 `nil`，代表一个没有类型的 Go `nil`。
- 字符 `.`（句号）: `.` 点号的值就是结果。
- 变量名，是一个字母和数字组成的字符串（可能为空），以美元符号开头，比如 `$piOver2` 或者 `$` 的结果是变量的值。关于变量的描述如下。
- 数据字段的名称，必须是一个结构体，以句号开头，比如 `.File` 的结果是这个字段的值。字段调用可以是链式的：`.Field1.Field2`，字段也可以在变量上计算，包括链式：`$x.Field1.Field2`。
- 数据中的值，必须是一个字典，以句号开头，比如 `.Key` 的结果是字典上这个键索引的元素的值。键调用可以是链式的，并且和字段组合到任何深度：`.Field.Key1.Field2.Key2`，尽管键必须是一个字母数字的标识符，不想字段名称，他们没有必要以大写字母开头。键也可以在变量中计算，包含链式：`$x.key1.key2`
- 数据方法的名称，以句号开头，比如 `.Method` 的结果是调用点号的方法的值，`dot.Method()`。这样的一个方法，必须有一个返回值（任意类型）或者两个返回值，第二个是错误。如果它有两个返回值，并且返回的错误是非 `nil`，执行中止，并且一个错误会作为执行的结果被返回给调用者。方法调用可以是链式的，并且可以和字段以及键组合到任意深度：`.Field1.Key1.Method1.Field2.Key2.Method2`，方法也可以在变量中计算，包括链式：`$x.Method1.Field`
- 函数的名称，比如 `fun` 的结果是一个函数调用的值，`fun()`。返回类型和值的行为和方法一样。关于函数和函数名称的描述如下。
- 上面的括号实例是为了分组。这个结果可以用来访问字段，或者字典键调用。打印 `(.F1 arg1) (.F2 arg2) (.StructValuedMethod "arg").Field`

参数可以计算成任何值，如果他们是指针，实现会自动在需要的时候指向他们的基类。如果一个计算返回了一个函数值，比如结构体的字段值是函数，这个函数不会自动调用，但是它可以被当成一个真实的值，用在 `if` 和其他动作中。要调用它，使用函数调用，下面有定义。

## 管道

管道是一串命令的链式序列。命令是简答的值（参数）或者函数或方法的调用，可能有多个参数：

```
Argument
    结果是参数的值
.Method [Argument...]
    方法可以单独或者是链的最后一个元素，但是和链中间的方法不同，它可以有多个参数。结果是用参数调用方法的值：
    参数：
        dot.Method(Argument1, etc.)
functionName [Argument...]
    结果是调用和名字关联的函数的值：
        function(Argument1, etc.)
    函数和函数名的描述如下
```

管道可以通过分开的一串命令使用管道符 `|` 被链起来。在一个管道链中，每个命令的结果被传递作为下一个命令的最后一个参数。最后命令的输出是整个管道的值。

命令的输出既可以是一个值也可以是两个值，第二值类型是 error，如果有第二个值并且不是 nil，执行会中止，并且这个错误会被返回给执行的调用者。

## 变量

动作里的管道可以初始化变量来捕获结果。初始化语法：

```
$variable := pipeline
```

`$variable` 是变量的名字，声明变量的动作没有输出。

之前声明过的变量也可以使用这个语法赋值

```
$variable = pipeline
```

如果 `range` 动作初始化了变量，这个变量会被设置成迭代器连续的元素。同样，`range` 也声明了两个变量，使用逗号分开：

```
range $index, $element := pipeline
```

这里例子中，`$index` 和 `$elemment` 被设置成连续的值，数组/切片索引和值或者字典的键和元素。注意如果只有一个变量，它会赋值给元素，这和传统的 go range 闭包是相反的。

变量的作用域延伸至其控制结构（`if`，`with`，`range`）的 `end` 动作，或者没有控制结构，整个模板从头到尾。模板的调用不会从其调用点继承变量。

调用开始时，`$` 被设置成数据参数传递来执行，这就是 `.` 开始的值。

## 例子

一些一行模板演示管道和变量的例子。所有这些都会输出 `"output"`

```
{{"\"output\""}}
    字符串常量
{{`output`}}
    裸字符串常量
{{printf "%q" "output"}}
    函数调用
{{"output" | printf "%q"}}
    函数调用，最后的参数来自于前一个命令
{{"printf" "%q" (print "out" "put")}}
    括起来的参数
{{"put" | printf "%s%s" "out" | printf "%q"}}
    更复杂的调用
{{"output" | printf "%s" | printf "%q"}}
    更长的链
{{with "output"}}{{printf "%q" .}}{{end}}
    使用点号的动作
{{with $x := "output" | printf "%q"}}{{$x}}{{end}}
    创建和使用变量的 with 动作
{{with $x := "output"}}{{printf "%q" $x}}{{end}}
    with 动作，在另一个动作中使用变量
{{with $x := "output"}}{{$x | printf "%q"}}{{end}}
    一样，只是使用了管道
```

## 函数

执行试，会在两个函数映射中找函数：模板和全局函数映射。默认情况下，没有函数在模板中定义，但是 `Funcs` 方法可以用来添加他们。

预定义的全局方法命名如下。

```
and
    返回它参数的布尔与运算，第一个参数或者第二个参数。这就是说 `and x y` 行为和 `if x then y else x` 一样，执行从做到右，确定结果时返回。
call
    返回第一个参数的调用结果，参数必须是函数，剩下的参数作为函数的参数。因此`call .X.Y 1 2`，在 go 中，`dot.X.Y(1, 2)`，`Y` 是值为函数的字段，字典的入口，或者类似的。第一个参数必须是生成函数类型的计算结果（和预定义函数比如 `print` 区别开来）。函数必须返回一个或者两个值，第二个值类型必须是 error。如果参数不是函数，或者返回了错误，执行中止。
html
    返回参数代表的文本的 html 转义。这个函数在 `html/template` 中是不可用的，会有一些异常
index
    返回第一个参数的索引，键值为接下来的参数。因此 `index x 1 2 3`，在 go 语法中是 `x[1][2][3]`。每个索引项都必须是一个字典，切片或者数组。
slice
    返回它第一个参数在剩下参数下的切片。因此 `slice x 1 2`，在 Go 语法中，`x[1:2]`，同时 `slice x` 表示 `x[:]`，`slice x 1` 表示 `x[1:]`，`slice x 1 2 3` 表示 `x[1:2:3]`，第一个参数必须是一个字符串，切片或者数组
js
    参数文本按照 JavaScript 转义
len
    参数的长度，整型
not
    参数的布尔非运算结果
or
    参数的布尔或运算结果，返回第一个非空参数或者最后一个参数，也就是说 `or x y` 和 `if x then x else y` 是一样的。执行从左到右，确定结果时返回
print
    fmt.Sprint 的别名
printf
    fmt.Sprintf 的别名
println
    fmt.Sprintln 的别名
urlquery
    参数文本的 url 转义，以适合内嵌入到 url 中。这个函数在 `html/template` 中不可用，会有一些异常
```

布尔函数将零值当成 false，非零值当成 true。

这里也有一些定义成函数的二元比较运算符

- eq: ==
- ne: !=
- lt: <
- le: <=
- gt: >
- ge: >=

对于更简单的多路等式测试，eq （只）接受两个或者更多的参数并且户比较第二个和第一个的结果，返回有效值

```
arg1==arg2 || arg1==arg3 || arg1==arg4 ...
```

（和 Go 的 `||` 不一样，eq 是一个函数，所有的参数都会被计算）

比较函数在任何 go 定义为可比较类型中都可以工作。对于基本类型，比如整型，规则是宽松的，大小和精度都被忽略，所以任何整型，有符号还是无符号，都可以和任何整型比较。（比较的是算术值，而不是位模式，所以所有负数比所有无符号数小。）然而，通常，不会拿 int 和 float32 比较等等。

## 关联模板

每一个模板在创建的时候所有一个字符串名字。同样，每一个模板都关联了零个或多个模板，他们可以用名字来调用；这种关联是可传递的，并形成命名空间。

模板可以用模板调用来实例化另一个关联模板；查看上面关于模板动作的解释。该名称必须是包含调用的模板关联的模板的名称。

## 内置模板定义

在解析模板的时候，另一个模板可以被定义和关联。模板定义必须出现在模板的顶层，和 go 程序的全局变量很像。

这种定义语法模板声明包含在 `define` 和 `end` 动作之间。

define 动作提供了一个字符串常量来命名被创建的模板。这是一个简单的例子：

```
{{define "T1"}}ONE{{end}}
{{define "T2"}}TWO{{end}}
{{define "T3"}}{{template "T1"}} {{template "T2"}}{{end}}
{{template "T3"}}
```

它定义了两个模板，T1 和 T2，以及第三个 T3 在执行的时候调用了另外两个。最后它调用了 T3。如果执行这个模板，会生成如下文本

```
ONE TWO
```

通过构造，模板可以只位于一个关联中，如果有必要让模板能从多个关联中访问，这个模板定义必须解析多次来创建多个不同的 `*Template` 值，或者必须用 `Clone` 或者 `AddParseTree` 方法。

解析可以调用多次来组装不同的关联模板；阅读 `ParseFiles` 和 `ParseGlob` 函数和方法来简化解析文件中保存的相关的模板。

模板可以通过 `ExecuteTemplate` 直接执行，这执行了一个用名字标识的关联模板。要调用我们上面的例子，我们可能会编写

```go
err := tmpl.Execute(os.Stdout, "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
```

或者用名称显示调用特别的模板

```go
err := tmpl.ExecuteTemplate(os.Stdout, "T2", "no data needed")
if err != nil {
	log.Fatalf("execution failed: %s", err)
}
```
